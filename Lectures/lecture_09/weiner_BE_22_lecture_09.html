<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Lecture 9: Gene expression and clustering</title>
    <meta charset="utf-8" />
    <meta name="author" content="January Weiner" />
    <meta name="date" content="2022-06-02" />
    <script src="libs/header-attrs-2.14/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="files/cubi-fonts.css" type="text/css" />
    <link rel="stylesheet" href="files/style.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Lecture 9: Gene expression and clustering
]
.subtitle[
## BE_22 Bioinformatics SS 21
]
.author[
### January Weiner
]
.date[
### 2022-06-02
]

---









&lt;!--
class:empty-slide,myinverse
background-image:url(images/arnolfini.jpg)
--&gt;






# Clustering

 * "unbiased" machine learning
 * group data points (samples, genes, ...) by similarity
 * applications in many areas of bioinformatics

---


.pull-left[
## Why cluster the genes?

 * Genes which are co-regulated have similar function `\(\rightarrow\)`
   identification of "transcriptional modules"
 * Analysis of the clusters may give us clues about what is happening in
   the biological system
 * Better visualization if genes are clustered

]

.pull-right[

&lt;img src="weiner_BE_22_lecture_09_files/figure-html/unnamed-chunk-3-1.png" width="60%" /&gt;
]

---
class:empty-slide,mywhite
background-image:url(images/network_1.png)


---
class:empty-slide,mywhite
background-image:url(images/network_2.png)

---

### From correlations to distances

 `\(d_{i,j}\)` – Distance between genes `\(i\)` and `\(j\)`

 `\(\rho(x_i, x_j)\)` – correlation coefficient between expression of `\(i\)` `\(x_i\)` and `\(j\)` `\(x_j\)`

Hard threshold:

 `$$d_{i,j} \equiv \left\{\begin{array}{ll}0 &amp; |\rho(x_i, x_j)| &gt; \tau\\1 &amp; |\rho(x_i, x_j)| \leq \tau\end{array}\right.$$`

Continuouos in `\((0, 1)\)`

 `$$d_{i,j} \equiv 1 - |\rho(x_i, x_j)|$$`


---
class:empty-slide,mywhite
background-image:url(images/correlation_modules.png)


---
class:empty-slide,mywhite
background-image:url(images/correlation_dependence.png)



---

## Many alternatives

 Other measures exist:

   * mutual information
   * different types of correlation (Spearman `\(\rho\)`, Kendall `\(\tau\)`)
   * distance correlation (Székely 2007)


Bottom line: we need to get at distances

---
class:empty-slide,myinverse
background-image:url(images/desert2.jpg)

.mytop[
The number of grains of sand in this picture accurately represents the
number of clustering algorithms.
]

--
.mytop[
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Each tree in the picture corresponds to a method of clustering which is
robust, reliable and provides automatically high quality clusters. 
]



---
class:empty-slide,myinverse
background-image:url(images/desert2.jpg)

.pull-left[
.transpblock[
**PAM** Partitioning Around Medoids. Similar to k-means;
predefined number of clusters
]

.transpblock[
**SOMs**, Self-organizing maps:
Train a neural network to recognize clusters in the data
(also SOTA: self-organizing trees)
]

.transpblock[
**SVC** – support vector clustering;
based on SVM’s (support vector machines)
]


.transpblock[
**Fuzzy C-means clustering**:
Each sample gets assigned a probability of
belonging to each of the clusters.
Algorithm similar to k-means.
Also similar – “soft k-means”
]

]

.pull-right[

.transpblock[
**Hierarchical clustering:** UPGMA (group-average linkage), Ward's method, neighbor joining, single
linkage, complete linkage...

]

.transpblock[
**Mclust** – model based clustering
The data is fit to a statistical model consisting of K normal distributions.
]

.transpblock[
**Density based clustering:**
identify clusters by local density profiles
]

]

---

### Hierarchical clustering

 * Start with each element in its own cluster: `\(n_{\text{clust}} = N\)`
 * Identify two elements with the smallest distance
 * Recalculate distances using a *linkage* function

E.g. complete linkage:

 `$$D(C_i, C_j) = \max_{e_i \in C_i, e_j \in C_j} D(e_i, e_j)$$`

Basically: join the clusters with the smalles distance between the
*furthest* elements of the clusters

E.g. single linkage:

 `$$D(C_i, C_j) = \min_{e_i \in C_i, e_j \in C_j} D(e_i, e_j)$$`

Basically: join the clusters with the smalles distance between the
*closest* elements of the clusters

---
class:empty-slide,mywhite
background-image:url(images/hclust.png)


---

## k-means

Naive k-means:

 * Assign the elements to random clusters
 * Repeat:
   * Calculate the cluster centroids (midpoints) 
   * Assign the elements to the cluster with the closest centroid
   * Abort if the asignments no longer change



.center[
![](weiner_BE_22_lecture_09_files/figure-html/unnamed-chunk-5-1.png)&lt;!-- --&gt;
]

---


.center[
![](weiner_BE_22_lecture_09_files/figure-html/unnamed-chunk-6-.gif)&lt;!-- --&gt;
]

---

## Measuring clustering performance

.pull-left[

 * How many clusters?

 * Which clustering method?

 * What parameters?
]

--

.pull-right[

 * Internal: information scientific

 * Stability measures: cross-validation, resampling (like bootstrapping in
   phylogenies!)

 * External: use external information
   * a priori information
   * biological information (how well the clusters correspond to
      underlying biology)

]

---
class:empty-slide,myinverse
background-image:url(images/desert2.jpg)

--

.mytop[
The number of grains of sand in this picture accurately represents the
number of available measures of clustering performance.
]


---

## The elbow method

.pull-left[
There is a total amount of variance in the clusters.

We can split it into *between cluster* variance and *within cluster*
variance.

Instead of variance, we use Sum of Squares (SS), because `\(Var(x)\equiv \frac{SS}{n-1}\)`.

 `$$SS_{\text{tot}} = SS_{\text{within}} + SS_{\text{between}}$$`

 * If all elements are in one large cluster, `\(SS_{\text{between}}= 0\)`.
 * If all elements are each in a separate cluster, `\(SS_{\text{within}}= 0\)`.
]

.pull-right[


![](images/elbow.png)


]

---

## Silhouette plots

.pull-left[

For each element, we plot the difference between distance to the center of
the cluster where that element is and the distance to the closest *other*
cluster center.

]

.pull-right[



![](weiner_BE_22_lecture_09_files/figure-html/unnamed-chunk-8-1.png)&lt;!-- --&gt;


]

---

![](weiner_BE_22_lecture_09_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;



---

![](weiner_BE_22_lecture_09_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;



---

![](weiner_BE_22_lecture_09_files/figure-html/unnamed-chunk-11-1.png)&lt;!-- --&gt;



---

Another example: clustering of single cell data

![](images/cell_1.png)

---

Another example: clustering of single cell data

![](images/cell_2.png)


---

Another example: clustering of single cell data

![](images/cell_3.png)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="files/macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
